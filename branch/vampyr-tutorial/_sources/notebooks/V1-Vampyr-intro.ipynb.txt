{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "c8752159-7c64-4101-a5f1-6626f2a87528",
   "metadata": {},
   "source": [
    "\n",
    "# Multiresolution Chemistry made easy (through Vampyr)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b71d5534-05c6-4dd5-a723-767ec8fcefd5",
   "metadata": {},
   "source": [
    "\n",
    "## 1 Vampyr prologue\n",
    "\n",
    "Import the packages like so"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f489d1a-3175-4e7c-a160-0041ff790431",
   "metadata": {},
   "outputs": [],
   "source": [
    "from vampyr import vampyr3d as vp\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7ddb54ed-1bff-4753-a32d-a8bdbb35104f",
   "metadata": {},
   "source": [
    "If you want to find out how to use a function, or what we have in the package use the function below"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15169ce8-769b-4dc2-b821-10cf18323bc2",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "help(vp.ScalingProjector)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "727a9451-6f7a-45e3-832f-a5dba0fd989a",
   "metadata": {},
   "source": [
    "In case the help was not enough, ask **us** for help. For this you need only your voice."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "675915bd-563c-4317-99f5-68cb25f3345c",
   "metadata": {},
   "source": [
    "\n",
    "## 2 Math in Vampyr\n",
    "\n",
    "The following exercises are introductions in working with functions, application of operators and some equation solving. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9c573970-55b2-41e9-8b15-a6f14f3a89ee",
   "metadata": {},
   "source": [
    "\n",
    "### 2.1 Projecting a function\n",
    "\n",
    "In this task you will create a function, project it at different precisions and basis orders, and plot it against its projection. \n",
    "This is meant to give you understanding in how one can approach completeness in multiwavelets.\n",
    "\n",
    "First we start by initializing the multiresolution analysis (mra) by using the following command"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cab8e2e3-57c4-4705-9033-a82b558b990d",
   "metadata": {},
   "outputs": [],
   "source": [
    "mra = vp.MultiResolutionAnalysis(box=[-20,20], order=7)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee7ce326-7033-409b-a6e9-83fdc63c6ffd",
   "metadata": {},
   "source": [
    "Here you will change the `order` value later. This defines the polynomial order of the basis."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b2f47c52-8681-4a01-bf77-26a1c35e8d13",
   "metadata": {},
   "source": [
    "An allowed function for projection in vampyr needs to have a single coordinate argument and it has to output a float value. You will construct a gaussian function defined by \n",
    "$$\n",
    "f(\\mathbf{r}) = \\beta \\exp(-\\alpha[r_x^2 + r_y^2 + r_z^2])\n",
    "$$\n",
    "the alpha value is a measure of how sharp the gaussian function is, and the beta is just a normalization factor, for this exercise you can set it to anything.\n",
    "Fill out the following python function for this"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f900f803-07ab-4d5e-97a4-378def767abc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def f(r):\n",
    "    # implement your function here\n",
    "    return\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "08fa2366-3740-4f5a-92bf-e3f345a4583b",
   "metadata": {},
   "source": [
    "You should then be able to plot this function by running the next cell"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49c605f6-43fd-4599-abd3-f28f51a3f9bb",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "r_x = np.linspace(-0.99, 0.99, 1000) # create an evenly spaced set of points between -0.99 and 0.99\n",
    "r_y = np.zeros(1000)\n",
    "r_z = np.zeros(1000)\n",
    "r = [r_x, r_y, r_z]\n",
    "\n",
    "plt.plot(r_x, f(r))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8dfa2466-3866-48c5-9929-ab1db8536b26",
   "metadata": {},
   "source": [
    "Now we want to project this function, the way we do that is by creating a projection operator `vp.ScalingProjector` and apply it on the function. We apply this operator by using the function as a function argument of it, `P(f)` for example.\n",
    "\n",
    "Try creating one and project the function you created earlier.\n",
    "\n",
    "hint: use the `help` function to fill out the blanks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ce98d1eb-0869-4fc8-a0a7-c8ba4def3302",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "### write your code here\n",
    "P_eps = \n",
    "\n",
    "f_tree =    # <-- here is where you will put the projected function"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d7cfbdaf-7fe0-4f54-8aff-58fc2e675d18",
   "metadata": {},
   "source": [
    "when you are done you can run the following cell to plot your projected function. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1a7bd52f-6144-4ade-bd05-3fdf46089065",
   "metadata": {},
   "outputs": [],
   "source": [
    "f_plt = [ f_tree([x, 0.0, 0.0]) for x in r_x ]\n",
    "plt.plot(r_x, f(r), \"tab:blue\") # your function\n",
    "plt.plot(r_x, f_plt, \"tab:red\") # your projected function\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "efea4679-c517-4af5-8775-6c2c1979d3ee",
   "metadata": {},
   "source": [
    "Now that you have projected the function, try changing three values, the `alpha` value of your original function, the `order` of the basis and the precision (`prec`) at which you project the function. What you should see is that the sharper the function, the higher order and precision you need to represent it properly. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "81858375-1cd8-4bd7-95de-7504de5e0ecd",
   "metadata": {},
   "source": [
    "One last thing I need to point out before we go to the next exercise is that it is convention to call our projected functions trees, as they all are `vp.FunctionTree` type."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ff5cc043-205c-4bf8-8475-18097cddacf5",
   "metadata": {},
   "source": [
    "\n",
    "### 2.2 Arithmethic\n",
    "\n",
    "Arithmethic in vampyr is mostly the same as in normal python.\n",
    "Lets work with the previous function you created.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40f18354-67ec-4d33-b714-07f5356dc6dc",
   "metadata": {},
   "source": [
    "First you can normalize your projected function by calling the function `normalize()` of `f_tree`.\n",
    "Try it in the next cell"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "83f4801e-bfba-4f23-ba32-cdb8f3cd0abc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# normalize your function here\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "28b59a46-3798-42e7-bc72-a70d2c1a68a5",
   "metadata": {},
   "source": [
    "Before we go on into the rest of the exercise, it is important to note that whenever a function is shown, and it doesn't start with `vp.`, it is assumed that it must be called as a member function of the tree, that is `f_tree.normalize()`, otherwise all functions must be called by using the `vp.` prefix."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c92b13c3-ea2e-47da-b971-22cc40270f44",
   "metadata": {},
   "source": [
    "Start by multiplying it by a factor of $2$ and assigning it to a new tree `g_tree`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d1cbb048-b9dd-4655-82d0-c7a26cede93f",
   "metadata": {},
   "outputs": [],
   "source": [
    "g_tree =  # <--- assign your rescaled function to this"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44a5cc61-3258-4b82-8669-d507e4f490e0",
   "metadata": {},
   "source": [
    "You should be able to compare it against `f_tree` by runnning the following cell"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5d5e96d2-a0ee-42f7-82ab-0c2e38a56462",
   "metadata": {},
   "outputs": [],
   "source": [
    "g_plt = [ g_tree([x, 0.0, 0.0]) for x in r_x ]\n",
    "plt.plot(r_x, g_plt, \"tab:red\")\n",
    "plt.plot(r_x, f_plt, \"tab:blue\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8bef5ce1-4cb0-463f-a882-b52e82771eb3",
   "metadata": {},
   "source": [
    "try adding `f_tree` and `g_tree` together"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6ae37856-8dda-4024-a2a7-361d4ff393c4",
   "metadata": {},
   "outputs": [],
   "source": [
    "h_tree =  # <--- assign your added functions to this"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f1b73e1b-2716-4220-a9ed-c6e7c6c74317",
   "metadata": {},
   "source": [
    "again, you can test this by plotting it against the two other functions by running the following cell"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "071d3c7a-3b2b-4752-9255-6f028cbda63f",
   "metadata": {},
   "outputs": [],
   "source": [
    "h_plt = [ h_tree([x, 0.0, 0.0]) for x in r_x ]\n",
    "\n",
    "plt.plot(r_x, h_plt, \"tab:orange\")\n",
    "plt.plot(r_x, g_plt, \"tab:red\")\n",
    "plt.plot(r_x, f_plt, \"tab:blue\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a13712ca-9eec-4f78-af03-3d542c0b06b8",
   "metadata": {},
   "source": [
    "You can also check that the norm of the different trees makes sense. This is done by calling the `norm()` value of your tree, try printing it below using the print function. The `f_tree` should be normalized, so its norm should be about $1.0$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b7726b5-c8e5-40af-93f5-a7c3305a4602",
   "metadata": {},
   "outputs": [],
   "source": [
    "print() # print the norm of your functions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "372ce16b-332e-4cb2-bce4-bf2853a3f459",
   "metadata": {},
   "source": [
    "Try multiplying your trees with the `*` operator, it should return a new tree which is the product of both, and you can check its norm again."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d41dad71-f5b7-454a-9ee6-7745235e2e53",
   "metadata": {},
   "outputs": [],
   "source": [
    "i_tree =  # <----- assign you multiplied functions to this"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "732e8940-a4ff-440d-b424-bb82654962ef",
   "metadata": {},
   "source": [
    "Finally, you can take the dot product, also called inner product, between two trees by using the `vp.dot` function. You can try this in the cell below. print out the norm of the product as shown above, is it what you would expect?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "83f9e7e1-92b3-4017-bc42-ab01a3e180fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# take the dot product of f_tree and g_tree"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eb2a2637-db7a-4703-b262-317379bb7aa6",
   "metadata": {},
   "source": [
    "\n",
    "## 2.3 Operators\n",
    "\n",
    "You have already worked with the `vp.ScalingProjector` and will work with the `vp.HelmholtzOperator`. In this part we will work with the Derivative operator, defined as `vp.ABGVDerivative`.\n",
    "Try constructing (with the help of `help()`) and applying the operator to your `f_tree`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1ffb427e-7713-4ed8-a983-e917b9d99ff3",
   "metadata": {},
   "outputs": [],
   "source": [
    "D =  # <--- initialize the ABGVDerivative operator here\n",
    "df_tree =  #  <-- set your differentiated f_tree here"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "afaba7af-8b9b-42f1-8308-437bc7e76aa8",
   "metadata": {},
   "source": [
    "Run the cell below to plot your differentiated function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1118a67a-4276-44e0-91cf-cf5f400e921d",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_plt = [ df_tree([x, 0.0, 0.0]) for x in r_x ]\n",
    "plt.plot(r_x, df_plt, \"tab:blue\") # your differentiated function\n",
    "plt.plot(r_x, f_plt, \"tab:red\") # your function tree\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "37571a78-a6bc-4527-ad8d-f5e5761f1599",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
